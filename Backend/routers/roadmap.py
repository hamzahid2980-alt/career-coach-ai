import sys
from pathlib import Path
from datetime import datetime, timedelta

# IMPORTANT: Ensure the 'backend' directory is on sys.path for local development
current_file_dir = Path(__file__).resolve().parent
backend_dir = current_file_dir.parent # Go up one level from 'routers' to 'backend'
if str(backend_dir) not in sys.path:
    sys.path.insert(0, str(backend_dir))

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build

from core.db_core import DatabaseManager
from core.ai_core import generate_career_roadmap, get_tutor_explanation, get_chatbot_response, evaluate_and_adjust_roadmap
msg = "" # Placeholder for optional messaging
from dependencies import get_db_manager, get_current_user

router = APIRouter()

class SyncRequest(BaseModel):
    google_access_token: str
    roadmap_data: Dict[str, Any]

@router.post("/sync")
async def sync_roadmap_endpoint(request: SyncRequest, user: dict = Depends(get_current_user)):
    try:
        # 1. Create Credentials using the token from the Frontend
        creds = Credentials(token=request.google_access_token)
        
        # 2. Connect to Google Services
        calendar_service = build('calendar', 'v3', credentials=creds)
        tasks_service = build('tasks', 'v1', credentials=creds)

        # --- CLEANUP: Delete existing AI Career Roadmap tasks and events ---
        try:
            # A. Cleanup Google Tasks
            # List all task lists to find the one named "AI Career Roadmap"
            tasklists_result = tasks_service.tasklists().list().execute()
            tasklists = tasklists_result.get('items', [])
            
            for t_list in tasklists:
                if t_list.get('title') == 'AI Career Roadmap':
                    # Deleting the task list automatically deletes all tasks inside it
                    try:
                        tasks_service.tasklists().delete(tasklist=t_list['id']).execute()
                        print(f"Deleted old task list: {t_list['id']}")
                    except Exception as e:
                        print(f"Warning: Failed to delete task list {t_list['id']}: {e}")
            
            # B. Cleanup Google Calendar Events
            # Find events tagged with our custom property 'source=ai_career_coach'
            page_token = None
            while True:
                events_result = calendar_service.events().list(
                    calendarId='primary',
                    privateExtendedProperty=['source=ai_career_coach'],
                    pageToken=page_token
                ).execute()
                
                events_to_delete = events_result.get('items', [])
                for old_event in events_to_delete:
                    try:
                        calendar_service.events().delete(calendarId='primary', eventId=old_event['id']).execute()
                    except Exception as e:
                        print(f"Warning: Failed to delete event {old_event['id']}: {e}")
                
                page_token = events_result.get('nextPageToken')
                if not page_token:
                    break
                    
        except Exception as cleanup_error:
             print(f"Non-critical cleanup error: {cleanup_error}")
             # Continue with creating new ones even if cleanup had hiccups

        # --- CREATION: Add new tasks and events ---

        # 3. Create a dedicated Task List for the Roadmap
        task_list = tasks_service.tasklists().insert(
            body={'title': 'AI Career Roadmap'}
        ).execute()
        task_list_id = task_list['id']

        created_events = 0

        # 4. Iterate through the roadmap and create tasks/events
        roadmap = request.roadmap_data
        if 'detailed_roadmap' in roadmap and isinstance(roadmap['detailed_roadmap'], list):
            # Start scheduling from tomorrow
            current_date = datetime.now() + timedelta(days=1)
            
            for phase in roadmap['detailed_roadmap']:
                phase_title = phase.get('phase_title', 'Phase')
                topics = phase.get('topics', [])
                
                for topic in topics:
                    topic_name = topic['name'] if isinstance(topic, dict) else topic
                    
                    # A. Add to Google Tasks
                    tasks_service.tasks().insert(
                        tasklist=task_list_id,
                        body={
                            'title': f"{phase_title}: {topic_name}",
                            'notes': "Generated by AI Career Coach",
                            'due': (current_date + timedelta(days=1)).isoformat() + 'Z'
                        }
                    ).execute()

                    # B. Add to Google Calendar (1-hour study block)
                    event = {
                        'summary': f"Study: {topic_name}",
                        'description': f"Phase: {phase_title}",
                        'start': {
                            'dateTime': current_date.isoformat(),
                            'timeZone': 'UTC', # Adjust if you have user timezone
                        },
                        'end': {
                            'dateTime': (current_date + timedelta(hours=1)).isoformat(),
                            'timeZone': 'UTC',
                        },
                        'extendedProperties': {
                            'private': {
                                'source': 'ai_career_coach'
                            }
                        }
                    }
                    calendar_service.events().insert(
                        calendarId='primary', 
                        body=event
                    ).execute()
                    
                    created_events += 1
                    # Spread tasks out: 1 task per day for simplicity
                    current_date += timedelta(days=1)

        return {"message": f"Sync Complete! Old entries removed. Added {created_events} new tasks/events."}

    except Exception as e:
        print(f"Sync Error: {e}")
        raise HTTPException(status_code=400, detail=f"Google Sync Failed: {str(e)}")

# --- Pydantic Models ---
class RoadmapRequest(BaseModel):
    current_skills_input: str
    current_level: str
    goal_input: str
    goal_level: str
    duration: str
    study_hours: str

class ChatbotRequest(BaseModel):
    query: str
    history: List[Dict[str, str]]
    career_plan: Dict[str, Any]

class TutorRequest(BaseModel):
    topic: str

class TaskStatusUpdateRequest(BaseModel):
    phase_title: str
    topic_name: str
    is_completed: bool

class PerformanceUpdateRequest(BaseModel):
    google_access_token: Optional[str] = None

# --- Helper Function ---
def initialize_roadmap_progress(roadmap_data: Dict[str, Any]) -> Dict[str, Any]:
    """Ensures every topic in the detailed roadmap is a dictionary with progress."""
    if 'detailed_roadmap' in roadmap_data and isinstance(roadmap_data['detailed_roadmap'], list):
        for phase in roadmap_data['detailed_roadmap']:
            if 'topics' in phase and isinstance(phase['topics'], list):
                phase['topics'] = [
                    {"name": topic, "is_completed": False} if isinstance(topic, str) else topic
                    for topic in phase['topics']
                ]
    return roadmap_data

# --- API Endpoints ---

@router.post("/generate")
async def generate_roadmap_endpoint(request: RoadmapRequest, user: dict = Depends(get_current_user), db: DatabaseManager = Depends(get_db_manager)):
    uid = user['uid']
    try:
        roadmap_output_raw = generate_career_roadmap(request.dict())
        if not roadmap_output_raw:
            raise HTTPException(status_code=500, detail="AI failed to generate a career roadmap.")
        roadmap_output = initialize_roadmap_progress(roadmap_output_raw)
        await db.save_user_roadmap(uid, roadmap_output)
        db.record_roadmap_generation(uid)
        return roadmap_output
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An internal server error occurred: {str(e)}")

@router.get("/latest")
async def get_latest_roadmap_endpoint(user: dict = Depends(get_current_user), db: DatabaseManager = Depends(get_db_manager)):
    uid = user['uid']
    try:
        roadmap = await db.get_user_roadmap(uid)
        if not roadmap:
            raise HTTPException(status_code=404, detail="No roadmap found for this user.")
        return initialize_roadmap_progress(roadmap)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An internal server error occurred: {str(e)}")

@router.post("/update_task_status")
async def update_roadmap_task_status_endpoint(request: TaskStatusUpdateRequest, user: dict = Depends(get_current_user), db: DatabaseManager = Depends(get_db_manager)):
    uid = user['uid']
    try:
        success = await db.update_roadmap_task_status(uid, request.phase_title, request.topic_name, request.is_completed)
        if not success:
            raise HTTPException(status_code=404, detail="Task not found or could not be updated.")
        return {"message": "Task status updated successfully."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An internal server error occurred: {str(e)}")

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An internal server error occurred: {str(e)}")

@router.post("/tutor")
async def get_tutor_response_endpoint(request: TutorRequest, user: dict = Depends(get_current_user)):
    try:
        tutor_response = get_tutor_explanation(request.topic)
        if not tutor_response:
            raise HTTPException(status_code=500, detail="AI tutor failed to provide an explanation.")
        return tutor_response
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An internal server error occurred: {str(e)}")

@router.get("/performance")
async def get_performance_endpoint(user: dict = Depends(get_current_user), db: DatabaseManager = Depends(get_db_manager)):
    """Returns a summary of the user's performance across assessments, interviews, and ATS."""
    return await db.get_user_performance_summary(user['uid'])

@router.post("/evaluate_and_update")
async def evaluate_and_update_roadmap_endpoint(request: PerformanceUpdateRequest, user: dict = Depends(get_current_user), db: DatabaseManager = Depends(get_db_manager)):
    """
    Dynamically evaluates the user's progress and adjusts the roadmap if they are off-track or excelling.
    If a Google Access Token is provided, it also re-syncs the updated roadmap.
    """
    uid = user['uid']
    try:
        # 1. Fetch current roadmap and performance summary
        roadmap = await db.get_user_roadmap(uid)
        if not roadmap:
            raise HTTPException(status_code=404, detail="No roadmap found to evaluate.")
        
        # Determine if we should force or check last update
        # For this endpoint, we always force as it's a manual trigger
        
        # 2. Fetch Collective Performance History
        performance_summary = await db.get_user_performance_summary(uid) # Basic summary
        trend_data = await db.get_performance_history(uid) # Detailed trends
        
        # 3. Call AI to adjust roadmap with Trend Data
        adjustment_result = evaluate_and_adjust_roadmap(roadmap, performance_summary, trend_data=trend_data)
        
        if not adjustment_result:
             raise HTTPException(status_code=500, detail="AI failed to evaluate roadmap adjustment.")
        
        if adjustment_result.get('is_updated'):
            # Carry over progress
            progress_map = {}
            if 'detailed_roadmap' in roadmap:
                for phase in roadmap['detailed_roadmap']:
                    for topic in phase.get('topics', []):
                        if isinstance(topic, dict) and topic.get('is_completed'):
                            progress_map[topic.get('name')] = True

            updated_data = adjustment_result['updated_roadmap']
            for key in ['detailed_roadmap', 'suggested_projects', 'skills_to_learn_summary']:
                if key in updated_data:
                    roadmap[key] = updated_data[key]
            
            roadmap = initialize_roadmap_progress(roadmap)

            if 'detailed_roadmap' in roadmap:
                for phase in roadmap['detailed_roadmap']:
                    for topic in phase.get('topics', []):
                        if isinstance(topic, dict) and topic.get('name') in progress_map:
                            topic['is_completed'] = True
            
            await db.save_user_roadmap(uid, roadmap, last_adjustment_reason=adjustment_result.get('performance_feedback', ""))
            sync_message = "Roadmap was updated based on your recent progress and collective trends."
        else:
            sync_message = "Your roadmap is already well-aligned with your current progress. Keep it up!"

        return {
            "message": sync_message,
            "feedback": adjustment_result.get('performance_feedback', ""),
            "is_updated": adjustment_result.get('is_updated', False),
            "roadmap": roadmap
        }

    except Exception as e:
        print(f"❌ Error in evaluate_and_update: {e}")
        raise HTTPException(status_code=500, detail=f"An internal server error occurred: {str(e)}")

@router.post("/check_auto_personalize")
async def check_auto_personalize_endpoint(user: dict = Depends(get_current_user), db: DatabaseManager = Depends(get_db_manager)):
    """
    Quietly checks if it's time for a weekly roadmap update.
    Returns the updated roadmap if a change occurred.
    """
    uid = user['uid']
    try:
        roadmap = await db.get_user_roadmap(uid)
        if not roadmap:
            return {"is_updated": False, "reason": "No roadmap found."}
        
        # Trigger same logic as evaluate_and_update
        performance_summary = await db.get_user_performance_summary(uid)
        trend_data = await db.get_performance_history(uid)
        
        # --- SMART BYPASS: If the user has a real score (>0) but the system thinks it's too early, force it.
        # This fixes the issue where a user starts with 0%, does tasks, but is stuck with the "0%" message for a week.
        current_composite = trend_data.get('composite_score', 0) if trend_data else 0
        
        last_upd_str = roadmap.get('last_personalized_at')
        if last_upd_str and current_composite == 0: # Only enforce 7-day wait if score is still 0 (or low)
             last_upd = datetime.fromisoformat(last_upd_str)
             # Use timezone-aware comparison if needed, or simple naive if stored is naive
             if last_upd.tzinfo is None: last_upd = last_upd.replace(tzinfo=None) # Ensure naive
             if datetime.now() - last_upd < timedelta(days=7):
                 return {"is_updated": False, "reason": "Updated less than 7 days ago."}
        
        # If we are here, we are either > 7 days OR we have a >0 score that needs to be shown.
        adjustment_result = evaluate_and_adjust_roadmap(roadmap, performance_summary, trend_data=trend_data)
        
        if adjustment_result and adjustment_result.get('is_updated'):
            progress_map = {}
            if 'detailed_roadmap' in roadmap:
                for phase in roadmap['detailed_roadmap']:
                    for topic in phase.get('topics', []):
                        if isinstance(topic, dict) and topic.get('is_completed'):
                            progress_map[topic.get('name')] = True

            updated_data = adjustment_result['updated_roadmap']
            for key in ['detailed_roadmap', 'suggested_projects', 'skills_to_learn_summary']:
                if key in updated_data:
                    roadmap[key] = updated_data[key]
            
            roadmap = initialize_roadmap_progress(roadmap)
            if 'detailed_roadmap' in roadmap:
                for phase in roadmap['detailed_roadmap']:
                    for topic in phase.get('topics', []):
                        if isinstance(topic, dict) and topic.get('name') in progress_map:
                            topic['is_completed'] = True
            
            await db.save_user_roadmap(uid, roadmap, last_adjustment_reason=adjustment_result.get('performance_feedback', ""))
            return {
                "is_updated": True,
                "message": "We've refined your roadmap based on your progress trends from this week!",
                "feedback": adjustment_result.get('performance_feedback', ""),
                "roadmap": roadmap
            }
        
        # Even if structure isn't updated (is_updated: False), we might have new FEEDBACK (insights).
        # We should save this feedback if it's different from the last one.
        if adjustment_result:
            new_feedback = adjustment_result.get('performance_feedback', "")
            if new_feedback and new_feedback != roadmap.get('last_adjustment_reason'):
                 # Save just the feedback/timestamp without changing the whole roadmap structure
                 roadmap['last_adjustment_reason'] = new_feedback
                 # We don't necessarily update 'last_personalized_at' to avoid resetting the 7-day timer for *structural* changes
                 await db.save_user_roadmap(uid, roadmap) 
                 # We force is_updated: True so the Frontend actually displays the new feedback text.
                 # Otherwise, it might ignore the response assuming nothing changed.
                 return {
                    "is_updated": True, 
                    "message": "Your insights have been updated based on your latest activity.",
                    "feedback": new_feedback,
                    "roadmap": roadmap
                 }
        
        return {"is_updated": False}
    except Exception as e:
        print(f"❌ Error in check_auto_personalize: {e}")
        return {"is_updated": False, "error": str(e)}

# --- CHATBOT SECTION ---

def _summarize_career_plan(plan: Dict[str, Any]) -> str:
    """
    Converts the detailed roadmap JSON into a concise and error-proof string summary for the AI.
    This "bulletproof" version checks the type of each data section before processing it.
    """
    if not isinstance(plan, dict):
        return "Error: Career plan data is malformed."
    parts = []
    
    skills = plan.get('skills_to_learn_summary')
    if isinstance(skills, list) and skills: parts.append(f"**Priority Skills:** {', '.join(skills)}")
    
    detailed_roadmap = plan.get('detailed_roadmap')
    if isinstance(detailed_roadmap, list):
        parts.append("\n**Learning Phases:**")
        for phase in detailed_roadmap:
            if not isinstance(phase, dict): continue
            phase_title = phase.get('phase_title', 'Unnamed Phase')
            topic_names = []
            topics = phase.get('topics')
            if isinstance(topics, list):
                for topic in topics:
                    if isinstance(topic, dict): topic_names.append(topic.get('name', ''))
                    elif isinstance(topic, str): topic_names.append(topic)
            valid_topic_names = [name for name in topic_names if name]
            parts.append(f"- **{phase_title}**: Topics are {', '.join(valid_topic_names)}.")

    suggested_projects = plan.get('suggested_projects')
    if isinstance(suggested_projects, list):
        parts.append("\n**Suggested Projects:**")
        for proj in suggested_projects:
             if isinstance(proj, dict): parts.append(f"- {proj.get('project_title', 'Untitled Project')}")

    suggested_courses = plan.get('suggested_courses')
    if isinstance(suggested_courses, list):
        parts.append("\n**Recommended Courses:**")
        for course in suggested_courses:
            if isinstance(course, dict): parts.append(f"- '{course.get('course_name', 'Unnamed Course')}' on {course.get('platform', 'N/A')}.")
    
    return "\n".join(parts) if parts else "No career plan details are available."

@router.post("/chat")
async def get_chatbot_response_endpoint(request: ChatbotRequest, user: dict = Depends(get_current_user)):
    try:
        plan_summary_str = _summarize_career_plan(request.career_plan)
        
        # --- DIAGNOSTIC LOGGING ---
        print("\n--- Chatbot Pre-flight Check ---")
        print(f"Type of data being passed to AI Core: {type(plan_summary_str)}")
        print("This should be <class 'str'>.")
        print("------------------------------\n")
        
        chatbot_response = get_chatbot_response(request.query, request.history, plan_summary_str)
        
        if not chatbot_response:
            raise HTTPException(status_code=500, detail="AI chatbot failed to generate a response.")
        return chatbot_response
    except Exception as e:
        print(f"❌ Chatbot Endpoint Error: {e}")
        raise HTTPException(status_code=500, detail=f"An internal server error occurred: {str(e)}")